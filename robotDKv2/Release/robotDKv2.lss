
robotDKv2.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000996  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .bss          00000053  00800200  00800200  00000a0a  2**0
                  ALLOC
  2 .debug_aranges 000007d0  00000000  00000000  00000a0a  2**0
                  CONTENTS, READONLY, DEBUGGING
  3 .debug_pubnames 0000133e  00000000  00000000  000011da  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   00008b69  00000000  00000000  00002518  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_abbrev 00001afc  00000000  00000000  0000b081  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_line   00004bf4  00000000  00000000  0000cb7d  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_frame  00000dc0  00000000  00000000  00011774  2**2
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_str    0000239b  00000000  00000000  00012534  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_loc    00005071  00000000  00000000  000148cf  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_ranges 000007d0  00000000  00000000  00019940  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
  // todo set speed to 0 ???
  motors[motor].run(RELEASE);      // stopped

}

void motorBrake(int motor)
   0:	0c 94 04 01 	jmp	0x208	; 0x208 <__ctors_end>
    SREG = oldSREG;
    return true;
  }

  return false;
}
   4:	0c 94 31 01 	jmp	0x262	; 0x262 <__bad_interrupt>
}

void AF_Stepper::setSpeed(uint16_t rpm) {
  usperstep = 60000000 / ((uint32_t)revsteps * (uint32_t)rpm);
  steppingcounter = 0;
}
   8:	0c 94 31 01 	jmp	0x262	; 0x262 <__bad_interrupt>
	timer0_millis = m;
	timer0_overflow_count++;
}

unsigned long millis()
{
   c:	0c 94 31 01 	jmp	0x262	; 0x262 <__bad_interrupt>

	SREG = oldSREG;
}

int digitalRead(uint8_t pin)
{
  10:	0c 94 31 01 	jmp	0x262	; 0x262 <__bad_interrupt>
  14:	0c 94 31 01 	jmp	0x262	; 0x262 <__bad_interrupt>
  18:	0c 94 31 01 	jmp	0x262	; 0x262 <__bad_interrupt>
  1c:	0c 94 31 01 	jmp	0x262	; 0x262 <__bad_interrupt>
  20:	0c 94 31 01 	jmp	0x262	; 0x262 <__bad_interrupt>
  24:	0c 94 af 01 	jmp	0x35e	; 0x35e <__vector_9>
  28:	0c 94 dd 01 	jmp	0x3ba	; 0x3ba <__vector_10>
  2c:	0c 94 0b 02 	jmp	0x416	; 0x416 <__vector_11>
  30:	0c 94 31 01 	jmp	0x262	; 0x262 <__bad_interrupt>
  34:	0c 94 31 01 	jmp	0x262	; 0x262 <__bad_interrupt>
  38:	0c 94 31 01 	jmp	0x262	; 0x262 <__bad_interrupt>
  3c:	0c 94 31 01 	jmp	0x262	; 0x262 <__bad_interrupt>
  40:	0c 94 31 01 	jmp	0x262	; 0x262 <__bad_interrupt>
  44:	0c 94 31 01 	jmp	0x262	; 0x262 <__bad_interrupt>
  48:	0c 94 31 01 	jmp	0x262	; 0x262 <__bad_interrupt>
  4c:	0c 94 31 01 	jmp	0x262	; 0x262 <__bad_interrupt>
  50:	0c 94 31 01 	jmp	0x262	; 0x262 <__bad_interrupt>
  54:	0c 94 31 01 	jmp	0x262	; 0x262 <__bad_interrupt>
  58:	0c 94 31 01 	jmp	0x262	; 0x262 <__bad_interrupt>
  5c:	0c 94 33 03 	jmp	0x666	; 0x666 <__vector_23>
  60:	0c 94 31 01 	jmp	0x262	; 0x262 <__bad_interrupt>
  64:	0c 94 31 01 	jmp	0x262	; 0x262 <__bad_interrupt>
  68:	0c 94 31 01 	jmp	0x262	; 0x262 <__bad_interrupt>
  6c:	0c 94 31 01 	jmp	0x262	; 0x262 <__bad_interrupt>
  70:	0c 94 31 01 	jmp	0x262	; 0x262 <__bad_interrupt>
  74:	0c 94 31 01 	jmp	0x262	; 0x262 <__bad_interrupt>
  78:	0c 94 31 01 	jmp	0x262	; 0x262 <__bad_interrupt>
  7c:	0c 94 31 01 	jmp	0x262	; 0x262 <__bad_interrupt>
  80:	0c 94 31 01 	jmp	0x262	; 0x262 <__bad_interrupt>
  84:	0c 94 31 01 	jmp	0x262	; 0x262 <__bad_interrupt>
  88:	0c 94 31 01 	jmp	0x262	; 0x262 <__bad_interrupt>
  8c:	0c 94 31 01 	jmp	0x262	; 0x262 <__bad_interrupt>
  90:	0c 94 31 01 	jmp	0x262	; 0x262 <__bad_interrupt>
  94:	0c 94 31 01 	jmp	0x262	; 0x262 <__bad_interrupt>
  98:	0c 94 31 01 	jmp	0x262	; 0x262 <__bad_interrupt>
  9c:	0c 94 31 01 	jmp	0x262	; 0x262 <__bad_interrupt>
  a0:	0c 94 31 01 	jmp	0x262	; 0x262 <__bad_interrupt>
  a4:	0c 94 31 01 	jmp	0x262	; 0x262 <__bad_interrupt>
  a8:	0c 94 31 01 	jmp	0x262	; 0x262 <__bad_interrupt>
  ac:	0c 94 31 01 	jmp	0x262	; 0x262 <__bad_interrupt>
  b0:	0c 94 31 01 	jmp	0x262	; 0x262 <__bad_interrupt>
  b4:	0c 94 31 01 	jmp	0x262	; 0x262 <__bad_interrupt>
  b8:	0c 94 31 01 	jmp	0x262	; 0x262 <__bad_interrupt>
  bc:	0c 94 31 01 	jmp	0x262	; 0x262 <__bad_interrupt>
  c0:	0c 94 31 01 	jmp	0x262	; 0x262 <__bad_interrupt>
  c4:	0c 94 31 01 	jmp	0x262	; 0x262 <__bad_interrupt>
  c8:	0c 94 31 01 	jmp	0x262	; 0x262 <__bad_interrupt>
  cc:	0c 94 31 01 	jmp	0x262	; 0x262 <__bad_interrupt>
  d0:	0c 94 31 01 	jmp	0x262	; 0x262 <__bad_interrupt>
  d4:	0c 94 31 01 	jmp	0x262	; 0x262 <__bad_interrupt>
  d8:	0c 94 31 01 	jmp	0x262	; 0x262 <__bad_interrupt>
  dc:	0c 94 31 01 	jmp	0x262	; 0x262 <__bad_interrupt>
  e0:	0c 94 31 01 	jmp	0x262	; 0x262 <__bad_interrupt>

000000e4 <port_to_mode_PGM>:
  e4:	00 00 21 00 24 00 27 00 2a 00 2d 00 30 00 33 00     ..!.$.'.*.-.0.3.
  f4:	01 01 00 00 04 01 07 01 0a 01                       ..........

000000fe <port_to_output_PGM>:
  fe:	00 00 22 00 25 00 28 00 2b 00 2e 00 31 00 34 00     ..".%.(.+...1.4.
 10e:	02 01 00 00 05 01 08 01 0b 01                       ..........

00000118 <port_to_input_PGM>:
 118:	00 00 20 00 23 00 26 00 29 00 2c 00 2f 00 32 00     .. .#.&.).,./.2.
 128:	00 01 00 00 03 01 06 01 09 01                       ..........

00000132 <digital_pin_to_port_PGM>:
 132:	05 05 05 05 07 05 08 08 08 08 02 02 02 02 0a 0a     ................
 142:	08 08 04 04 04 04 01 01 01 01 01 01 01 01 03 03     ................
 152:	03 03 03 03 03 03 04 07 07 07 0c 0c 0c 0c 0c 0c     ................
 162:	0c 0c 02 02 02 02 06 06 06 06 06 06 06 06 0b 0b     ................
 172:	0b 0b 0b 0b 0b 0b                                   ......

00000178 <digital_pin_to_bit_mask_PGM>:
 178:	01 02 10 20 20 08 08 10 20 40 10 20 40 80 02 01     ...  ... @. @...
 188:	02 01 08 04 02 01 01 02 04 08 10 20 40 80 80 40     ........... @..@
 198:	20 10 08 04 02 01 80 04 02 01 80 40 20 10 08 04      ..........@ ...
 1a8:	02 01 08 04 02 01 01 02 04 08 10 20 40 80 01 02     ........... @...
 1b8:	04 08 10 20 40 80                                   ... @.

000001be <digital_pin_to_timer_PGM>:
 1be:	00 00 09 0a 02 08 0b 0c 0d 07 06 03 04 01 00 00     ................
	...
 1ea:	11 10 0f 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
	...

00000204 <__ctors_start>:
 204:	33 01       	movw	r6, r6
 206:	39 02       	muls	r19, r25

00000208 <__ctors_end>:
 208:	11 24       	eor	r1, r1
 20a:	1f be       	out	0x3f, r1	; 63
 20c:	cf ef       	ldi	r28, 0xFF	; 255
 20e:	d1 e2       	ldi	r29, 0x21	; 33
 210:	de bf       	out	0x3e, r29	; 62
 212:	cd bf       	out	0x3d, r28	; 61
 214:	00 e0       	ldi	r16, 0x00	; 0
 216:	0c bf       	out	0x3c, r16	; 60

00000218 <__do_copy_data>:
 218:	12 e0       	ldi	r17, 0x02	; 2
 21a:	a0 e0       	ldi	r26, 0x00	; 0
 21c:	b2 e0       	ldi	r27, 0x02	; 2
 21e:	e6 e9       	ldi	r30, 0x96	; 150
 220:	f9 e0       	ldi	r31, 0x09	; 9
 222:	00 e0       	ldi	r16, 0x00	; 0
 224:	0b bf       	out	0x3b, r16	; 59
 226:	02 c0       	rjmp	.+4      	; 0x22c <__do_copy_data+0x14>
 228:	07 90       	elpm	r0, Z+
 22a:	0d 92       	st	X+, r0
 22c:	a0 30       	cpi	r26, 0x00	; 0
 22e:	b1 07       	cpc	r27, r17
 230:	d9 f7       	brne	.-10     	; 0x228 <__do_copy_data+0x10>
 232:	1b be       	out	0x3b, r1	; 59

00000234 <__do_clear_bss>:
 234:	12 e0       	ldi	r17, 0x02	; 2
 236:	a0 e0       	ldi	r26, 0x00	; 0
 238:	b2 e0       	ldi	r27, 0x02	; 2
 23a:	01 c0       	rjmp	.+2      	; 0x23e <.do_clear_bss_start>

0000023c <.do_clear_bss_loop>:
 23c:	1d 92       	st	X+, r1

0000023e <.do_clear_bss_start>:
 23e:	a3 35       	cpi	r26, 0x53	; 83
 240:	b1 07       	cpc	r27, r17
 242:	e1 f7       	brne	.-8      	; 0x23c <.do_clear_bss_loop>

00000244 <__do_global_ctors>:
 244:	12 e0       	ldi	r17, 0x02	; 2
 246:	c8 e0       	ldi	r28, 0x08	; 8
 248:	d2 e0       	ldi	r29, 0x02	; 2
 24a:	04 c0       	rjmp	.+8      	; 0x254 <.do_global_ctors_start>

0000024c <.do_global_ctors_loop>:
 24c:	22 97       	sbiw	r28, 0x02	; 2
 24e:	fe 01       	movw	r30, r28
 250:	0e 94 c5 04 	call	0x98a	; 0x98a <__tablejump__>

00000254 <.do_global_ctors_start>:
 254:	c4 30       	cpi	r28, 0x04	; 4
 256:	d1 07       	cpc	r29, r17
 258:	c9 f7       	brne	.-14     	; 0x24c <.do_global_ctors_loop>
 25a:	0e 94 24 03 	call	0x648	; 0x648 <main>
 25e:	0c 94 c9 04 	jmp	0x992	; 0x992 <_exit>

00000262 <__bad_interrupt>:
 262:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000266 <_GLOBAL__I_MIN_SPEED>:
{
  motors[motor].run(BRAKE);      // stopped

}
 266:	0f 93       	push	r16
 268:	1f 93       	push	r17
int rotationTime[NBR_SPEEDS] = {5500, 3300, 2400, 2000, 1750, 1550, 1150}; // time

AF_DCMotor motors[] = {
    AF_DCMotor (3), // left is Motor #1
    AF_DCMotor (4)  // right is Motor #2
};
 26a:	00 e0       	ldi	r16, 0x00	; 0
 26c:	12 e0       	ldi	r17, 0x02	; 2
 26e:	c8 01       	movw	r24, r16
 270:	63 e0       	ldi	r22, 0x03	; 3
 272:	42 e0       	ldi	r20, 0x02	; 2
 274:	0e 94 d5 02 	call	0x5aa	; 0x5aa <_ZN10AF_DCMotorC1Ehh>
 278:	c8 01       	movw	r24, r16
 27a:	02 96       	adiw	r24, 0x02	; 2
 27c:	64 e0       	ldi	r22, 0x04	; 4
 27e:	42 e0       	ldi	r20, 0x02	; 2
 280:	0e 94 d5 02 	call	0x5aa	; 0x5aa <_ZN10AF_DCMotorC1Ehh>

void motorBrake(int motor)
{
  motors[motor].run(BRAKE);      // stopped

}
 284:	1f 91       	pop	r17
 286:	0f 91       	pop	r16
 288:	08 95       	ret

0000028a <_ZN14SoftwareSerial4recvEv>:

//
// The receive routine called by the interrupt handler
//
void SoftwareSerial::recv()
 28a:	0f 93       	push	r16
 28c:	1f 93       	push	r17
 28e:	cf 93       	push	r28
 290:	df 93       	push	r29
 292:	fc 01       	movw	r30, r24

  uint8_t d = 0;

  // If RX line is high, then we don't see any start bit
  // so interrupt is probably not for us
  if (_inverse_logic ? rx_pin_read() : !rx_pin_read())
 294:	73 8d       	ldd	r23, Z+27	; 0x1b
 296:	76 95       	lsr	r23
 298:	71 70       	andi	r23, 0x01	; 1
 29a:	a6 85       	ldd	r26, Z+14	; 0x0e
 29c:	b7 85       	ldd	r27, Z+15	; 0x0f
 29e:	95 85       	ldd	r25, Z+13	; 0x0d
 2a0:	77 23       	and	r23, r23
 2a2:	29 f0       	breq	.+10     	; 0x2ae <_ZN14SoftwareSerial4recvEv+0x24>
    *_transmitPortRegister |= _transmitBitMask;
}

uint8_t SoftwareSerial::rx_pin_read()
{
  return *_receivePortRegister & _receiveBitMask;
 2a4:	8c 91       	ld	r24, X

  uint8_t d = 0;

  // If RX line is high, then we don't see any start bit
  // so interrupt is probably not for us
  if (_inverse_logic ? rx_pin_read() : !rx_pin_read())
 2a6:	89 23       	and	r24, r25
 2a8:	09 f4       	brne	.+2      	; 0x2ac <_ZN14SoftwareSerial4recvEv+0x22>
 2aa:	54 c0       	rjmp	.+168    	; 0x354 <_ZN14SoftwareSerial4recvEv+0xca>
 2ac:	04 c0       	rjmp	.+8      	; 0x2b6 <_ZN14SoftwareSerial4recvEv+0x2c>
    *_transmitPortRegister |= _transmitBitMask;
}

uint8_t SoftwareSerial::rx_pin_read()
{
  return *_receivePortRegister & _receiveBitMask;
 2ae:	8c 91       	ld	r24, X

  uint8_t d = 0;

  // If RX line is high, then we don't see any start bit
  // so interrupt is probably not for us
  if (_inverse_logic ? rx_pin_read() : !rx_pin_read())
 2b0:	89 23       	and	r24, r25
 2b2:	09 f0       	breq	.+2      	; 0x2b6 <_ZN14SoftwareSerial4recvEv+0x2c>
 2b4:	4f c0       	rjmp	.+158    	; 0x354 <_ZN14SoftwareSerial4recvEv+0xca>
  {
    // Wait approximately 1/2 of a bit width to "center" the sample
    tunedDelay(_rx_delay_centering);
 2b6:	83 89       	ldd	r24, Z+19	; 0x13
 2b8:	94 89       	ldd	r25, Z+20	; 0x14
    "cpi %A0, 0xFF \n\t"
    "cpc %B0, %1 \n\t"
    "brne .-10 \n\t"
    : "+r" (delay), "+a" (tmp)
    : "0" (delay)
    );
 2ba:	20 e0       	ldi	r18, 0x00	; 0
 2bc:	01 97       	sbiw	r24, 0x01	; 1
 2be:	2f ef       	ldi	r18, 0xFF	; 255
 2c0:	8f 3f       	cpi	r24, 0xFF	; 255
 2c2:	92 07       	cpc	r25, r18
 2c4:	d9 f7       	brne	.-10     	; 0x2bc <_ZN14SoftwareSerial4recvEv+0x32>
    DebugPulse(_DEBUG_PIN2, 1);

    // Read each of the 8 bits
    for (uint8_t i=0x1; i; i <<= 1)
    {
      tunedDelay(_rx_delay_intrabit);
 2c6:	c5 89       	ldd	r28, Z+21	; 0x15
 2c8:	d6 89       	ldd	r29, Z+22	; 0x16
    *_transmitPortRegister |= _transmitBitMask;
}

uint8_t SoftwareSerial::rx_pin_read()
{
  return *_receivePortRegister & _receiveBitMask;
 2ca:	a6 85       	ldd	r26, Z+14	; 0x0e
 2cc:	b7 85       	ldd	r27, Z+15	; 0x0f
 2ce:	15 85       	ldd	r17, Z+13	; 0x0d
 2d0:	60 e0       	ldi	r22, 0x00	; 0
 2d2:	31 e0       	ldi	r19, 0x01	; 1
 2d4:	40 e0       	ldi	r20, 0x00	; 0
 2d6:	50 e0       	ldi	r21, 0x00	; 0
    "cpi %A0, 0xFF \n\t"
    "cpc %B0, %1 \n\t"
    "brne .-10 \n\t"
    : "+r" (delay), "+a" (tmp)
    : "0" (delay)
    );
 2d8:	00 e0       	ldi	r16, 0x00	; 0
 2da:	ce 01       	movw	r24, r28
 2dc:	20 2f       	mov	r18, r16
 2de:	01 97       	sbiw	r24, 0x01	; 1
 2e0:	2f ef       	ldi	r18, 0xFF	; 255
 2e2:	8f 3f       	cpi	r24, 0xFF	; 255
 2e4:	92 07       	cpc	r25, r18
 2e6:	d9 f7       	brne	.-10     	; 0x2de <_ZN14SoftwareSerial4recvEv+0x54>
    *_transmitPortRegister |= _transmitBitMask;
}

uint8_t SoftwareSerial::rx_pin_read()
{
  return *_receivePortRegister & _receiveBitMask;
 2e8:	8c 91       	ld	r24, X
    for (uint8_t i=0x1; i; i <<= 1)
    {
      tunedDelay(_rx_delay_intrabit);
      DebugPulse(_DEBUG_PIN2, 1);
      uint8_t noti = ~i;
      if (rx_pin_read())
 2ea:	81 23       	and	r24, r17
 2ec:	11 f0       	breq	.+4      	; 0x2f2 <_ZN14SoftwareSerial4recvEv+0x68>
        d |= i;
 2ee:	63 2b       	or	r22, r19
 2f0:	03 c0       	rjmp	.+6      	; 0x2f8 <_ZN14SoftwareSerial4recvEv+0x6e>
      else // else clause added to ensure function timing is ~balanced
        d &= noti;
 2f2:	83 2f       	mov	r24, r19
 2f4:	80 95       	com	r24
 2f6:	68 23       	and	r22, r24
    // Wait approximately 1/2 of a bit width to "center" the sample
    tunedDelay(_rx_delay_centering);
    DebugPulse(_DEBUG_PIN2, 1);

    // Read each of the 8 bits
    for (uint8_t i=0x1; i; i <<= 1)
 2f8:	33 0f       	add	r19, r19
 2fa:	4f 5f       	subi	r20, 0xFF	; 255
 2fc:	5f 4f       	sbci	r21, 0xFF	; 255
 2fe:	48 30       	cpi	r20, 0x08	; 8
 300:	51 05       	cpc	r21, r1
 302:	59 f7       	brne	.-42     	; 0x2da <_ZN14SoftwareSerial4recvEv+0x50>
      else // else clause added to ensure function timing is ~balanced
        d &= noti;
    }

    // skip the stop bit
    tunedDelay(_rx_delay_stopbit);
 304:	87 89       	ldd	r24, Z+23	; 0x17
 306:	90 8d       	ldd	r25, Z+24	; 0x18
    "cpi %A0, 0xFF \n\t"
    "cpc %B0, %1 \n\t"
    "brne .-10 \n\t"
    : "+r" (delay), "+a" (tmp)
    : "0" (delay)
    );
 308:	20 e0       	ldi	r18, 0x00	; 0
 30a:	01 97       	sbiw	r24, 0x01	; 1
 30c:	2f ef       	ldi	r18, 0xFF	; 255
 30e:	8f 3f       	cpi	r24, 0xFF	; 255
 310:	92 07       	cpc	r25, r18
 312:	d9 f7       	brne	.-10     	; 0x30a <_ZN14SoftwareSerial4recvEv+0x80>

    // skip the stop bit
    tunedDelay(_rx_delay_stopbit);
    DebugPulse(_DEBUG_PIN2, 1);

    if (_inverse_logic)
 314:	71 11       	cpse	r23, r1
      d = ~d;
 316:	60 95       	com	r22

    // if buffer full, set the overflow flag and return
    if ((_receive_buffer_tail + 1) % _SS_MAX_RX_BUFF != _receive_buffer_head) 
 318:	80 91 46 02 	lds	r24, 0x0246
 31c:	20 91 47 02 	lds	r18, 0x0247
 320:	90 e0       	ldi	r25, 0x00	; 0
 322:	01 96       	adiw	r24, 0x01	; 1
 324:	8f 73       	andi	r24, 0x3F	; 63
 326:	90 70       	andi	r25, 0x00	; 0
 328:	30 e0       	ldi	r19, 0x00	; 0
 32a:	82 17       	cp	r24, r18
 32c:	93 07       	cpc	r25, r19
 32e:	79 f0       	breq	.+30     	; 0x34e <_ZN14SoftwareSerial4recvEv+0xc4>
    {
      // save new data in buffer: tail points to where byte goes
      _receive_buffer[_receive_buffer_tail] = d; // save new byte
 330:	e0 91 46 02 	lds	r30, 0x0246
 334:	f0 e0       	ldi	r31, 0x00	; 0
 336:	ea 5f       	subi	r30, 0xFA	; 250
 338:	fd 4f       	sbci	r31, 0xFD	; 253
 33a:	60 83       	st	Z, r22
      _receive_buffer_tail = (_receive_buffer_tail + 1) % _SS_MAX_RX_BUFF;
 33c:	80 91 46 02 	lds	r24, 0x0246
 340:	90 e0       	ldi	r25, 0x00	; 0
 342:	01 96       	adiw	r24, 0x01	; 1
 344:	8f 73       	andi	r24, 0x3F	; 63
 346:	90 70       	andi	r25, 0x00	; 0
 348:	80 93 46 02 	sts	0x0246, r24
 34c:	03 c0       	rjmp	.+6      	; 0x354 <_ZN14SoftwareSerial4recvEv+0xca>
    else 
    {
#if _DEBUG // for scope: pulse pin as overflow indictator
      DebugPulse(_DEBUG_PIN1, 1);
#endif
      _buffer_overflow = true;
 34e:	83 8d       	ldd	r24, Z+27	; 0x1b
 350:	81 60       	ori	r24, 0x01	; 1
 352:	83 8f       	std	Z+27, r24	; 0x1b
    "pop r20 \n\t"
    "pop r19 \n\t"
    "pop r18 \n\t"
    ::);
#endif
}
 354:	df 91       	pop	r29
 356:	cf 91       	pop	r28
 358:	1f 91       	pop	r17
 35a:	0f 91       	pop	r16
 35c:	08 95       	ret

0000035e <__vector_9>:
    active_object->recv();
  }
}

#if defined(PCINT0_vect)
ISR(PCINT0_vect)
 35e:	1f 92       	push	r1
 360:	0f 92       	push	r0
 362:	0f b6       	in	r0, 0x3f	; 63
 364:	0f 92       	push	r0
 366:	0b b6       	in	r0, 0x3b	; 59
 368:	0f 92       	push	r0
 36a:	11 24       	eor	r1, r1
 36c:	2f 93       	push	r18
 36e:	3f 93       	push	r19
 370:	4f 93       	push	r20
 372:	5f 93       	push	r21
 374:	6f 93       	push	r22
 376:	7f 93       	push	r23
 378:	8f 93       	push	r24
 37a:	9f 93       	push	r25
 37c:	af 93       	push	r26
 37e:	bf 93       	push	r27
 380:	ef 93       	push	r30
 382:	ff 93       	push	r31
//

/* static */
inline void SoftwareSerial::handle_interrupt()
{
  if (active_object)
 384:	80 91 04 02 	lds	r24, 0x0204
 388:	90 91 05 02 	lds	r25, 0x0205
 38c:	00 97       	sbiw	r24, 0x00	; 0
 38e:	11 f0       	breq	.+4      	; 0x394 <__vector_9+0x36>
  {
    active_object->recv();
 390:	0e 94 45 01 	call	0x28a	; 0x28a <_ZN14SoftwareSerial4recvEv>

#if defined(PCINT0_vect)
ISR(PCINT0_vect)
{
  SoftwareSerial::handle_interrupt();
}
 394:	ff 91       	pop	r31
 396:	ef 91       	pop	r30
 398:	bf 91       	pop	r27
 39a:	af 91       	pop	r26
 39c:	9f 91       	pop	r25
 39e:	8f 91       	pop	r24
 3a0:	7f 91       	pop	r23
 3a2:	6f 91       	pop	r22
 3a4:	5f 91       	pop	r21
 3a6:	4f 91       	pop	r20
 3a8:	3f 91       	pop	r19
 3aa:	2f 91       	pop	r18
 3ac:	0f 90       	pop	r0
 3ae:	0b be       	out	0x3b, r0	; 59
 3b0:	0f 90       	pop	r0
 3b2:	0f be       	out	0x3f, r0	; 63
 3b4:	0f 90       	pop	r0
 3b6:	1f 90       	pop	r1
 3b8:	18 95       	reti

000003ba <__vector_10>:
#endif

#if defined(PCINT1_vect)
ISR(PCINT1_vect)
 3ba:	1f 92       	push	r1
 3bc:	0f 92       	push	r0
 3be:	0f b6       	in	r0, 0x3f	; 63
 3c0:	0f 92       	push	r0
 3c2:	0b b6       	in	r0, 0x3b	; 59
 3c4:	0f 92       	push	r0
 3c6:	11 24       	eor	r1, r1
 3c8:	2f 93       	push	r18
 3ca:	3f 93       	push	r19
 3cc:	4f 93       	push	r20
 3ce:	5f 93       	push	r21
 3d0:	6f 93       	push	r22
 3d2:	7f 93       	push	r23
 3d4:	8f 93       	push	r24
 3d6:	9f 93       	push	r25
 3d8:	af 93       	push	r26
 3da:	bf 93       	push	r27
 3dc:	ef 93       	push	r30
 3de:	ff 93       	push	r31
//

/* static */
inline void SoftwareSerial::handle_interrupt()
{
  if (active_object)
 3e0:	80 91 04 02 	lds	r24, 0x0204
 3e4:	90 91 05 02 	lds	r25, 0x0205
 3e8:	00 97       	sbiw	r24, 0x00	; 0
 3ea:	11 f0       	breq	.+4      	; 0x3f0 <__vector_10+0x36>
  {
    active_object->recv();
 3ec:	0e 94 45 01 	call	0x28a	; 0x28a <_ZN14SoftwareSerial4recvEv>

#if defined(PCINT1_vect)
ISR(PCINT1_vect)
{
  SoftwareSerial::handle_interrupt();
}
 3f0:	ff 91       	pop	r31
 3f2:	ef 91       	pop	r30
 3f4:	bf 91       	pop	r27
 3f6:	af 91       	pop	r26
 3f8:	9f 91       	pop	r25
 3fa:	8f 91       	pop	r24
 3fc:	7f 91       	pop	r23
 3fe:	6f 91       	pop	r22
 400:	5f 91       	pop	r21
 402:	4f 91       	pop	r20
 404:	3f 91       	pop	r19
 406:	2f 91       	pop	r18
 408:	0f 90       	pop	r0
 40a:	0b be       	out	0x3b, r0	; 59
 40c:	0f 90       	pop	r0
 40e:	0f be       	out	0x3f, r0	; 63
 410:	0f 90       	pop	r0
 412:	1f 90       	pop	r1
 414:	18 95       	reti

00000416 <__vector_11>:
#endif

#if defined(PCINT2_vect)
ISR(PCINT2_vect)
 416:	1f 92       	push	r1
 418:	0f 92       	push	r0
 41a:	0f b6       	in	r0, 0x3f	; 63
 41c:	0f 92       	push	r0
 41e:	0b b6       	in	r0, 0x3b	; 59
 420:	0f 92       	push	r0
 422:	11 24       	eor	r1, r1
 424:	2f 93       	push	r18
 426:	3f 93       	push	r19
 428:	4f 93       	push	r20
 42a:	5f 93       	push	r21
 42c:	6f 93       	push	r22
 42e:	7f 93       	push	r23
 430:	8f 93       	push	r24
 432:	9f 93       	push	r25
 434:	af 93       	push	r26
 436:	bf 93       	push	r27
 438:	ef 93       	push	r30
 43a:	ff 93       	push	r31
//

/* static */
inline void SoftwareSerial::handle_interrupt()
{
  if (active_object)
 43c:	80 91 04 02 	lds	r24, 0x0204
 440:	90 91 05 02 	lds	r25, 0x0205
 444:	00 97       	sbiw	r24, 0x00	; 0
 446:	11 f0       	breq	.+4      	; 0x44c <__vector_11+0x36>
  {
    active_object->recv();
 448:	0e 94 45 01 	call	0x28a	; 0x28a <_ZN14SoftwareSerial4recvEv>

#if defined(PCINT2_vect)
ISR(PCINT2_vect)
{
  SoftwareSerial::handle_interrupt();
}
 44c:	ff 91       	pop	r31
 44e:	ef 91       	pop	r30
 450:	bf 91       	pop	r27
 452:	af 91       	pop	r26
 454:	9f 91       	pop	r25
 456:	8f 91       	pop	r24
 458:	7f 91       	pop	r23
 45a:	6f 91       	pop	r22
 45c:	5f 91       	pop	r21
 45e:	4f 91       	pop	r20
 460:	3f 91       	pop	r19
 462:	2f 91       	pop	r18
 464:	0f 90       	pop	r0
 466:	0b be       	out	0x3b, r0	; 59
 468:	0f 90       	pop	r0
 46a:	0f be       	out	0x3f, r0	; 63
 46c:	0f 90       	pop	r0
 46e:	1f 90       	pop	r1
 470:	18 95       	reti

00000472 <_GLOBAL__I_microstepcurve>:
#elif (MICROSTEPS == 16)
uint8_t microstepcurve[] = {0, 25, 50, 74, 98, 120, 141, 162, 180, 197, 212, 225, 236, 244, 250, 253, 255};
#endif

AFMotorController::AFMotorController(void) {
    TimerInitalized = false;
 472:	10 92 48 02 	sts	0x0248, r1
  }

 
  MC.latch_tx();
  return currentstep;
}
 476:	08 95       	ret

00000478 <_Z8initPWM1h>:
    TCCR2A |= _BV(COM2A1) | _BV(WGM20) | _BV(WGM21); // fast PWM, turn on oc2a
    TCCR2B = freq & 0x7;
    OCR2A = 0;
#elif defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)
    // on arduino mega, pin 11 is now PB5 (OC1A)
    TCCR1A |= _BV(COM1A1) | _BV(WGM10); // fast PWM, turn on oc1a
 478:	e0 e8       	ldi	r30, 0x80	; 128
 47a:	f0 e0       	ldi	r31, 0x00	; 0
 47c:	90 81       	ld	r25, Z
 47e:	91 68       	ori	r25, 0x81	; 129
 480:	90 83       	st	Z, r25
    TCCR1B = (freq & 0x7) | _BV(WGM12);
 482:	87 70       	andi	r24, 0x07	; 7
 484:	88 60       	ori	r24, 0x08	; 8
 486:	80 93 81 00 	sts	0x0081, r24
    OCR1A = 0;
 48a:	10 92 89 00 	sts	0x0089, r1
 48e:	10 92 88 00 	sts	0x0088, r1
    #endif
#else
   #error "This chip is not supported!"
#endif
    #if !defined(PIC32_USE_PIN9_FOR_M1_PWM) && !defined(PIC32_USE_PIN10_FOR_M1_PWM)
        pinMode(11, OUTPUT);
 492:	8b e0       	ldi	r24, 0x0B	; 11
 494:	61 e0       	ldi	r22, 0x01	; 1
 496:	0e 94 dd 03 	call	0x7ba	; 0x7ba <pinMode>
    #endif
}
 49a:	08 95       	ret

0000049c <_Z8initPWM2h>:
    TCCR2A |= _BV(COM2B1) | _BV(WGM20) | _BV(WGM21); // fast PWM, turn on oc2b
    TCCR2B = freq & 0x7;
    OCR2B = 0;
#elif defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)
    // on arduino mega, pin 3 is now PE5 (OC3C)
    TCCR3A |= _BV(COM1C1) | _BV(WGM10); // fast PWM, turn on oc3c
 49c:	e0 e9       	ldi	r30, 0x90	; 144
 49e:	f0 e0       	ldi	r31, 0x00	; 0
 4a0:	90 81       	ld	r25, Z
 4a2:	99 60       	ori	r25, 0x09	; 9
 4a4:	90 83       	st	Z, r25
    TCCR3B = (freq & 0x7) | _BV(WGM12);
 4a6:	87 70       	andi	r24, 0x07	; 7
 4a8:	88 60       	ori	r24, 0x08	; 8
 4aa:	80 93 91 00 	sts	0x0091, r24
    OCR3C = 0;
 4ae:	10 92 9d 00 	sts	0x009D, r1
 4b2:	10 92 9c 00 	sts	0x009C, r1
    OC1R = 0x0000;
#else
   #error "This chip is not supported!"
#endif

    pinMode(3, OUTPUT);
 4b6:	83 e0       	ldi	r24, 0x03	; 3
 4b8:	61 e0       	ldi	r22, 0x01	; 1
 4ba:	0e 94 dd 03 	call	0x7ba	; 0x7ba <pinMode>
}
 4be:	08 95       	ret

000004c0 <_Z8initPWM3h>:
    TCCR0A |= _BV(COM0A1) | _BV(WGM00) | _BV(WGM01); // fast PWM, turn on OC0A
    //TCCR0B = freq & 0x7;
    OCR0A = 0;
#elif defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)
    // on arduino mega, pin 6 is now PH3 (OC4A)
    TCCR4A |= _BV(COM1A1) | _BV(WGM10); // fast PWM, turn on oc4a
 4c0:	e0 ea       	ldi	r30, 0xA0	; 160
 4c2:	f0 e0       	ldi	r31, 0x00	; 0
 4c4:	90 81       	ld	r25, Z
 4c6:	91 68       	ori	r25, 0x81	; 129
 4c8:	90 83       	st	Z, r25
    TCCR4B = (freq & 0x7) | _BV(WGM12);
 4ca:	87 70       	andi	r24, 0x07	; 7
 4cc:	88 60       	ori	r24, 0x08	; 8
 4ce:	80 93 a1 00 	sts	0x00A1, r24
    //TCCR4B = 1 | _BV(WGM12);
    OCR4A = 0;
 4d2:	10 92 a9 00 	sts	0x00A9, r1
 4d6:	10 92 a8 00 	sts	0x00A8, r1
    OC3RS = 0x0000;
    OC3R = 0x0000;
#else
   #error "This chip is not supported!"
#endif
    pinMode(6, OUTPUT);
 4da:	86 e0       	ldi	r24, 0x06	; 6
 4dc:	61 e0       	ldi	r22, 0x01	; 1
 4de:	0e 94 dd 03 	call	0x7ba	; 0x7ba <pinMode>
}
 4e2:	08 95       	ret

000004e4 <_Z8initPWM4h>:
    TCCR0A |= _BV(COM0B1) | _BV(WGM00) | _BV(WGM01); // fast PWM, turn on oc0a
    //TCCR0B = freq & 0x7;
    OCR0B = 0;
#elif defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)
    // on arduino mega, pin 5 is now PE3 (OC3A)
    TCCR3A |= _BV(COM1A1) | _BV(WGM10); // fast PWM, turn on oc3a
 4e4:	e0 e9       	ldi	r30, 0x90	; 144
 4e6:	f0 e0       	ldi	r31, 0x00	; 0
 4e8:	90 81       	ld	r25, Z
 4ea:	91 68       	ori	r25, 0x81	; 129
 4ec:	90 83       	st	Z, r25
    TCCR3B = (freq & 0x7) | _BV(WGM12);
 4ee:	87 70       	andi	r24, 0x07	; 7
 4f0:	88 60       	ori	r24, 0x08	; 8
 4f2:	80 93 91 00 	sts	0x0091, r24
    //TCCR4B = 1 | _BV(WGM12);
    OCR3A = 0;
 4f6:	10 92 99 00 	sts	0x0099, r1
 4fa:	10 92 98 00 	sts	0x0098, r1
    OC2RS = 0x0000;
    OC2R = 0x0000;
#else
   #error "This chip is not supported!"
#endif
    pinMode(5, OUTPUT);
 4fe:	85 e0       	ldi	r24, 0x05	; 5
 500:	61 e0       	ldi	r22, 0x01	; 1
 502:	0e 94 dd 03 	call	0x7ba	; 0x7ba <pinMode>
}
 506:	08 95       	ret

00000508 <_ZN17AFMotorController8latch_txEv>:
  //ENABLE_PORT &= ~_BV(ENABLE); // enable the chip outputs!
  digitalWrite(MOTORENABLE, LOW);
}


void AFMotorController::latch_tx(void) {
 508:	cf 93       	push	r28
 50a:	df 93       	push	r29
  uint8_t i;

  //LATCH_PORT &= ~_BV(LATCH);
  digitalWrite(MOTORLATCH, LOW);
 50c:	82 e0       	ldi	r24, 0x02	; 2
 50e:	60 e0       	ldi	r22, 0x00	; 0
 510:	0e 94 90 04 	call	0x920	; 0x920 <digitalWrite>

  //SER_PORT &= ~_BV(SER);
  digitalWrite(MOTORDATA, LOW);
 514:	88 e0       	ldi	r24, 0x08	; 8
 516:	60 e0       	ldi	r22, 0x00	; 0
 518:	0e 94 90 04 	call	0x920	; 0x920 <digitalWrite>
 51c:	c7 e0       	ldi	r28, 0x07	; 7
 51e:	d0 e0       	ldi	r29, 0x00	; 0

  for (i=0; i<8; i++) {
    //CLK_PORT &= ~_BV(CLK);
    digitalWrite(MOTORCLK, LOW);
 520:	84 e0       	ldi	r24, 0x04	; 4
 522:	60 e0       	ldi	r22, 0x00	; 0
 524:	0e 94 90 04 	call	0x920	; 0x920 <digitalWrite>

    if (latch_state & _BV(7-i)) {
 528:	80 91 49 02 	lds	r24, 0x0249
 52c:	90 e0       	ldi	r25, 0x00	; 0
 52e:	0c 2e       	mov	r0, r28
 530:	02 c0       	rjmp	.+4      	; 0x536 <_ZN17AFMotorController8latch_txEv+0x2e>
 532:	95 95       	asr	r25
 534:	87 95       	ror	r24
 536:	0a 94       	dec	r0
 538:	e2 f7       	brpl	.-8      	; 0x532 <_ZN17AFMotorController8latch_txEv+0x2a>
 53a:	80 ff       	sbrs	r24, 0
 53c:	03 c0       	rjmp	.+6      	; 0x544 <_ZN17AFMotorController8latch_txEv+0x3c>
      //SER_PORT |= _BV(SER);
      digitalWrite(MOTORDATA, HIGH);
 53e:	88 e0       	ldi	r24, 0x08	; 8
 540:	61 e0       	ldi	r22, 0x01	; 1
 542:	02 c0       	rjmp	.+4      	; 0x548 <_ZN17AFMotorController8latch_txEv+0x40>
    } else {
      //SER_PORT &= ~_BV(SER);
      digitalWrite(MOTORDATA, LOW);
 544:	88 e0       	ldi	r24, 0x08	; 8
 546:	60 e0       	ldi	r22, 0x00	; 0
 548:	0e 94 90 04 	call	0x920	; 0x920 <digitalWrite>
    }
    //CLK_PORT |= _BV(CLK);
    digitalWrite(MOTORCLK, HIGH);
 54c:	84 e0       	ldi	r24, 0x04	; 4
 54e:	61 e0       	ldi	r22, 0x01	; 1
 550:	0e 94 90 04 	call	0x920	; 0x920 <digitalWrite>
 554:	21 97       	sbiw	r28, 0x01	; 1
  digitalWrite(MOTORLATCH, LOW);

  //SER_PORT &= ~_BV(SER);
  digitalWrite(MOTORDATA, LOW);

  for (i=0; i<8; i++) {
 556:	8f ef       	ldi	r24, 0xFF	; 255
 558:	cf 3f       	cpi	r28, 0xFF	; 255
 55a:	d8 07       	cpc	r29, r24
 55c:	09 f7       	brne	.-62     	; 0x520 <_ZN17AFMotorController8latch_txEv+0x18>
    }
    //CLK_PORT |= _BV(CLK);
    digitalWrite(MOTORCLK, HIGH);
  }
  //LATCH_PORT |= _BV(LATCH);
  digitalWrite(MOTORLATCH, HIGH);
 55e:	82 e0       	ldi	r24, 0x02	; 2
 560:	61 e0       	ldi	r22, 0x01	; 1
 562:	0e 94 90 04 	call	0x920	; 0x920 <digitalWrite>
}
 566:	df 91       	pop	r29
 568:	cf 91       	pop	r28
 56a:	08 95       	ret

0000056c <_ZN17AFMotorController6enableEv>:

AFMotorController::AFMotorController(void) {
    TimerInitalized = false;
}

void AFMotorController::enable(void) {
 56c:	0f 93       	push	r16
 56e:	1f 93       	push	r17
 570:	8c 01       	movw	r16, r24
  LATCH_DDR |= _BV(LATCH);
  ENABLE_DDR |= _BV(ENABLE);
  CLK_DDR |= _BV(CLK);
  SER_DDR |= _BV(SER);
  */
  pinMode(MOTORLATCH, OUTPUT);
 572:	82 e0       	ldi	r24, 0x02	; 2
 574:	61 e0       	ldi	r22, 0x01	; 1
 576:	0e 94 dd 03 	call	0x7ba	; 0x7ba <pinMode>
  pinMode(MOTORENABLE, OUTPUT);
 57a:	83 e0       	ldi	r24, 0x03	; 3
 57c:	61 e0       	ldi	r22, 0x01	; 1
 57e:	0e 94 dd 03 	call	0x7ba	; 0x7ba <pinMode>
  pinMode(MOTORDATA, OUTPUT);
 582:	88 e0       	ldi	r24, 0x08	; 8
 584:	61 e0       	ldi	r22, 0x01	; 1
 586:	0e 94 dd 03 	call	0x7ba	; 0x7ba <pinMode>
  pinMode(MOTORCLK, OUTPUT);
 58a:	84 e0       	ldi	r24, 0x04	; 4
 58c:	61 e0       	ldi	r22, 0x01	; 1
 58e:	0e 94 dd 03 	call	0x7ba	; 0x7ba <pinMode>

  latch_state = 0;
 592:	10 92 49 02 	sts	0x0249, r1

  latch_tx();  // "reset"
 596:	c8 01       	movw	r24, r16
 598:	0e 94 84 02 	call	0x508	; 0x508 <_ZN17AFMotorController8latch_txEv>

  //ENABLE_PORT &= ~_BV(ENABLE); // enable the chip outputs!
  digitalWrite(MOTORENABLE, LOW);
 59c:	83 e0       	ldi	r24, 0x03	; 3
 59e:	60 e0       	ldi	r22, 0x00	; 0
 5a0:	0e 94 90 04 	call	0x920	; 0x920 <digitalWrite>
}
 5a4:	1f 91       	pop	r17
 5a6:	0f 91       	pop	r16
 5a8:	08 95       	ret

000005aa <_ZN10AF_DCMotorC1Ehh>:
#else
   #error "This chip is not supported!"
#endif
}

AF_DCMotor::AF_DCMotor(uint8_t num, uint8_t freq) {
 5aa:	0f 93       	push	r16
 5ac:	1f 93       	push	r17
 5ae:	fc 01       	movw	r30, r24
 5b0:	16 2f       	mov	r17, r22
 5b2:	04 2f       	mov	r16, r20
  motornum = num;
 5b4:	60 83       	st	Z, r22
  pwmfreq = freq;
 5b6:	41 83       	std	Z+1, r20	; 0x01

  MC.enable();
 5b8:	88 e4       	ldi	r24, 0x48	; 72
 5ba:	92 e0       	ldi	r25, 0x02	; 2
 5bc:	0e 94 b6 02 	call	0x56c	; 0x56c <_ZN17AFMotorController6enableEv>

  switch (num) {
 5c0:	12 30       	cpi	r17, 0x02	; 2
 5c2:	b9 f0       	breq	.+46     	; 0x5f2 <_ZN10AF_DCMotorC1Ehh+0x48>
 5c4:	13 30       	cpi	r17, 0x03	; 3
 5c6:	18 f4       	brcc	.+6      	; 0x5ce <_ZN10AF_DCMotorC1Ehh+0x24>
 5c8:	11 30       	cpi	r17, 0x01	; 1
 5ca:	c9 f5       	brne	.+114    	; 0x63e <_ZN10AF_DCMotorC1Ehh+0x94>
 5cc:	05 c0       	rjmp	.+10     	; 0x5d8 <_ZN10AF_DCMotorC1Ehh+0x2e>
 5ce:	13 30       	cpi	r17, 0x03	; 3
 5d0:	e9 f0       	breq	.+58     	; 0x60c <_ZN10AF_DCMotorC1Ehh+0x62>
 5d2:	14 30       	cpi	r17, 0x04	; 4
 5d4:	a1 f5       	brne	.+104    	; 0x63e <_ZN10AF_DCMotorC1Ehh+0x94>
 5d6:	27 c0       	rjmp	.+78     	; 0x626 <_ZN10AF_DCMotorC1Ehh+0x7c>
  case 1:
    latch_state &= ~_BV(MOTOR1_A) & ~_BV(MOTOR1_B); // set both motor pins to 0
 5d8:	80 91 49 02 	lds	r24, 0x0249
 5dc:	83 7f       	andi	r24, 0xF3	; 243
 5de:	80 93 49 02 	sts	0x0249, r24
    MC.latch_tx();
 5e2:	88 e4       	ldi	r24, 0x48	; 72
 5e4:	92 e0       	ldi	r25, 0x02	; 2
 5e6:	0e 94 84 02 	call	0x508	; 0x508 <_ZN17AFMotorController8latch_txEv>
    initPWM1(freq);
 5ea:	80 2f       	mov	r24, r16
 5ec:	0e 94 3c 02 	call	0x478	; 0x478 <_Z8initPWM1h>
 5f0:	26 c0       	rjmp	.+76     	; 0x63e <_ZN10AF_DCMotorC1Ehh+0x94>
    break;
  case 2:
    latch_state &= ~_BV(MOTOR2_A) & ~_BV(MOTOR2_B); // set both motor pins to 0
 5f2:	80 91 49 02 	lds	r24, 0x0249
 5f6:	8d 7e       	andi	r24, 0xED	; 237
 5f8:	80 93 49 02 	sts	0x0249, r24
    MC.latch_tx();
 5fc:	88 e4       	ldi	r24, 0x48	; 72
 5fe:	92 e0       	ldi	r25, 0x02	; 2
 600:	0e 94 84 02 	call	0x508	; 0x508 <_ZN17AFMotorController8latch_txEv>
    initPWM2(freq);
 604:	80 2f       	mov	r24, r16
 606:	0e 94 4e 02 	call	0x49c	; 0x49c <_Z8initPWM2h>
 60a:	19 c0       	rjmp	.+50     	; 0x63e <_ZN10AF_DCMotorC1Ehh+0x94>
    break;
  case 3:
    latch_state &= ~_BV(MOTOR3_A) & ~_BV(MOTOR3_B); // set both motor pins to 0
 60c:	80 91 49 02 	lds	r24, 0x0249
 610:	8f 75       	andi	r24, 0x5F	; 95
 612:	80 93 49 02 	sts	0x0249, r24
    MC.latch_tx();
 616:	88 e4       	ldi	r24, 0x48	; 72
 618:	92 e0       	ldi	r25, 0x02	; 2
 61a:	0e 94 84 02 	call	0x508	; 0x508 <_ZN17AFMotorController8latch_txEv>
    initPWM3(freq);
 61e:	80 2f       	mov	r24, r16
 620:	0e 94 60 02 	call	0x4c0	; 0x4c0 <_Z8initPWM3h>
 624:	0c c0       	rjmp	.+24     	; 0x63e <_ZN10AF_DCMotorC1Ehh+0x94>
    break;
  case 4:
    latch_state &= ~_BV(MOTOR4_A) & ~_BV(MOTOR4_B); // set both motor pins to 0
 626:	80 91 49 02 	lds	r24, 0x0249
 62a:	8e 7b       	andi	r24, 0xBE	; 190
 62c:	80 93 49 02 	sts	0x0249, r24
    MC.latch_tx();
 630:	88 e4       	ldi	r24, 0x48	; 72
 632:	92 e0       	ldi	r25, 0x02	; 2
 634:	0e 94 84 02 	call	0x508	; 0x508 <_ZN17AFMotorController8latch_txEv>
    initPWM4(freq);
 638:	80 2f       	mov	r24, r16
 63a:	0e 94 72 02 	call	0x4e4	; 0x4e4 <_Z8initPWM4h>
    break;
  }
}
 63e:	1f 91       	pop	r17
 640:	0f 91       	pop	r16
 642:	08 95       	ret

00000644 <setup>:

//The setup function is called once at startup of the sketch
void setup()
{
// Add your initialization code here
}
 644:	08 95       	ret

00000646 <loop>:

// The loop function is called in an endless loop
void loop()
{
//Add your repeated code here
}
 646:	08 95       	ret

00000648 <main>:
#include <Arduino.h>

int main(void)
 648:	cf 93       	push	r28
 64a:	df 93       	push	r29
{
	init();
 64c:	0e 94 7b 03 	call	0x6f6	; 0x6f6 <init>

#if defined(USBCON)
	USBDevice.attach();
#endif
	
	setup();
 650:	0e 94 22 03 	call	0x644	; 0x644 <setup>
    
	for (;;) {
		loop();
		if (serialEventRun) serialEventRun();
 654:	c0 e0       	ldi	r28, 0x00	; 0
 656:	d0 e0       	ldi	r29, 0x00	; 0
#endif
	
	setup();
    
	for (;;) {
		loop();
 658:	0e 94 23 03 	call	0x646	; 0x646 <loop>
		if (serialEventRun) serialEventRun();
 65c:	20 97       	sbiw	r28, 0x00	; 0
 65e:	e1 f3       	breq	.-8      	; 0x658 <main+0x10>
 660:	0e 94 00 00 	call	0	; 0x0 <__vectors>
 664:	f9 cf       	rjmp	.-14     	; 0x658 <main+0x10>

00000666 <__vector_23>:
#if defined(__AVR_ATtiny24__) || defined(__AVR_ATtiny44__) || defined(__AVR_ATtiny84__)
ISR(TIM0_OVF_vect)
#else
ISR(TIMER0_OVF_vect)
#endif
{
 666:	1f 92       	push	r1
 668:	0f 92       	push	r0
 66a:	0f b6       	in	r0, 0x3f	; 63
 66c:	0f 92       	push	r0
 66e:	11 24       	eor	r1, r1
 670:	2f 93       	push	r18
 672:	3f 93       	push	r19
 674:	8f 93       	push	r24
 676:	9f 93       	push	r25
 678:	af 93       	push	r26
 67a:	bf 93       	push	r27
	// copy these to local variables so they can be stored in registers
	// (volatile variables must be read from memory on every access)
	unsigned long m = timer0_millis;
 67c:	80 91 4e 02 	lds	r24, 0x024E
 680:	90 91 4f 02 	lds	r25, 0x024F
 684:	a0 91 50 02 	lds	r26, 0x0250
 688:	b0 91 51 02 	lds	r27, 0x0251
	unsigned char f = timer0_fract;
 68c:	30 91 52 02 	lds	r19, 0x0252

	m += MILLIS_INC;
 690:	01 96       	adiw	r24, 0x01	; 1
 692:	a1 1d       	adc	r26, r1
 694:	b1 1d       	adc	r27, r1
	f += FRACT_INC;
 696:	23 2f       	mov	r18, r19
 698:	2d 5f       	subi	r18, 0xFD	; 253
	if (f >= FRACT_MAX) {
 69a:	2d 37       	cpi	r18, 0x7D	; 125
 69c:	20 f0       	brcs	.+8      	; 0x6a6 <__vector_23+0x40>
		f -= FRACT_MAX;
 69e:	2d 57       	subi	r18, 0x7D	; 125
		m += 1;
 6a0:	01 96       	adiw	r24, 0x01	; 1
 6a2:	a1 1d       	adc	r26, r1
 6a4:	b1 1d       	adc	r27, r1
	}

	timer0_fract = f;
 6a6:	20 93 52 02 	sts	0x0252, r18
	timer0_millis = m;
 6aa:	80 93 4e 02 	sts	0x024E, r24
 6ae:	90 93 4f 02 	sts	0x024F, r25
 6b2:	a0 93 50 02 	sts	0x0250, r26
 6b6:	b0 93 51 02 	sts	0x0251, r27
	timer0_overflow_count++;
 6ba:	80 91 4a 02 	lds	r24, 0x024A
 6be:	90 91 4b 02 	lds	r25, 0x024B
 6c2:	a0 91 4c 02 	lds	r26, 0x024C
 6c6:	b0 91 4d 02 	lds	r27, 0x024D
 6ca:	01 96       	adiw	r24, 0x01	; 1
 6cc:	a1 1d       	adc	r26, r1
 6ce:	b1 1d       	adc	r27, r1
 6d0:	80 93 4a 02 	sts	0x024A, r24
 6d4:	90 93 4b 02 	sts	0x024B, r25
 6d8:	a0 93 4c 02 	sts	0x024C, r26
 6dc:	b0 93 4d 02 	sts	0x024D, r27
}
 6e0:	bf 91       	pop	r27
 6e2:	af 91       	pop	r26
 6e4:	9f 91       	pop	r25
 6e6:	8f 91       	pop	r24
 6e8:	3f 91       	pop	r19
 6ea:	2f 91       	pop	r18
 6ec:	0f 90       	pop	r0
 6ee:	0f be       	out	0x3f, r0	; 63
 6f0:	0f 90       	pop	r0
 6f2:	1f 90       	pop	r1
 6f4:	18 95       	reti

000006f6 <init>:

void init()
{
	// this needs to be called before setup() or some functions won't
	// work there
	sei();
 6f6:	78 94       	sei
	
	// on the ATmega168, timer 0 is also used for fast hardware pwm
	// (using phase-correct PWM would mean that timer 0 overflowed half as often
	// resulting in different millis() behavior on the ATmega8 and ATmega168)
#if defined(TCCR0A) && defined(WGM01)
	sbi(TCCR0A, WGM01);
 6f8:	84 b5       	in	r24, 0x24	; 36
 6fa:	82 60       	ori	r24, 0x02	; 2
 6fc:	84 bd       	out	0x24, r24	; 36
	sbi(TCCR0A, WGM00);
 6fe:	84 b5       	in	r24, 0x24	; 36
 700:	81 60       	ori	r24, 0x01	; 1
 702:	84 bd       	out	0x24, r24	; 36
	// this combination is for the standard atmega8
	sbi(TCCR0, CS01);
	sbi(TCCR0, CS00);
#elif defined(TCCR0B) && defined(CS01) && defined(CS00)
	// this combination is for the standard 168/328/1280/2560
	sbi(TCCR0B, CS01);
 704:	85 b5       	in	r24, 0x25	; 37
 706:	82 60       	ori	r24, 0x02	; 2
 708:	85 bd       	out	0x25, r24	; 37
	sbi(TCCR0B, CS00);
 70a:	85 b5       	in	r24, 0x25	; 37
 70c:	81 60       	ori	r24, 0x01	; 1
 70e:	85 bd       	out	0x25, r24	; 37

	// enable timer 0 overflow interrupt
#if defined(TIMSK) && defined(TOIE0)
	sbi(TIMSK, TOIE0);
#elif defined(TIMSK0) && defined(TOIE0)
	sbi(TIMSK0, TOIE0);
 710:	ee e6       	ldi	r30, 0x6E	; 110
 712:	f0 e0       	ldi	r31, 0x00	; 0
 714:	80 81       	ld	r24, Z
 716:	81 60       	ori	r24, 0x01	; 1
 718:	80 83       	st	Z, r24
	// this is better for motors as it ensures an even waveform
	// note, however, that fast pwm mode can achieve a frequency of up
	// 8 MHz (with a 16 MHz clock) at 50% duty cycle

#if defined(TCCR1B) && defined(CS11) && defined(CS10)
	TCCR1B = 0;
 71a:	e1 e8       	ldi	r30, 0x81	; 129
 71c:	f0 e0       	ldi	r31, 0x00	; 0
 71e:	10 82       	st	Z, r1

	// set timer 1 prescale factor to 64
	sbi(TCCR1B, CS11);
 720:	80 81       	ld	r24, Z
 722:	82 60       	ori	r24, 0x02	; 2
 724:	80 83       	st	Z, r24
#if F_CPU >= 8000000L
	sbi(TCCR1B, CS10);
 726:	80 81       	ld	r24, Z
 728:	81 60       	ori	r24, 0x01	; 1
 72a:	80 83       	st	Z, r24
	sbi(TCCR1, CS10);
#endif
#endif
	// put timer 1 in 8-bit phase correct pwm mode
#if defined(TCCR1A) && defined(WGM10)
	sbi(TCCR1A, WGM10);
 72c:	e0 e8       	ldi	r30, 0x80	; 128
 72e:	f0 e0       	ldi	r31, 0x00	; 0
 730:	80 81       	ld	r24, Z
 732:	81 60       	ori	r24, 0x01	; 1
 734:	80 83       	st	Z, r24

	// set timer 2 prescale factor to 64
#if defined(TCCR2) && defined(CS22)
	sbi(TCCR2, CS22);
#elif defined(TCCR2B) && defined(CS22)
	sbi(TCCR2B, CS22);
 736:	e1 eb       	ldi	r30, 0xB1	; 177
 738:	f0 e0       	ldi	r31, 0x00	; 0
 73a:	80 81       	ld	r24, Z
 73c:	84 60       	ori	r24, 0x04	; 4
 73e:	80 83       	st	Z, r24

	// configure timer 2 for phase correct pwm (8-bit)
#if defined(TCCR2) && defined(WGM20)
	sbi(TCCR2, WGM20);
#elif defined(TCCR2A) && defined(WGM20)
	sbi(TCCR2A, WGM20);
 740:	e0 eb       	ldi	r30, 0xB0	; 176
 742:	f0 e0       	ldi	r31, 0x00	; 0
 744:	80 81       	ld	r24, Z
 746:	81 60       	ori	r24, 0x01	; 1
 748:	80 83       	st	Z, r24
#else
	#warning Timer 2 not finished (may not be present on this CPU)
#endif

#if defined(TCCR3B) && defined(CS31) && defined(WGM30)
	sbi(TCCR3B, CS31);		// set timer 3 prescale factor to 64
 74a:	e1 e9       	ldi	r30, 0x91	; 145
 74c:	f0 e0       	ldi	r31, 0x00	; 0
 74e:	80 81       	ld	r24, Z
 750:	82 60       	ori	r24, 0x02	; 2
 752:	80 83       	st	Z, r24
	sbi(TCCR3B, CS30);
 754:	80 81       	ld	r24, Z
 756:	81 60       	ori	r24, 0x01	; 1
 758:	80 83       	st	Z, r24
	sbi(TCCR3A, WGM30);		// put timer 3 in 8-bit phase correct pwm mode
 75a:	e0 e9       	ldi	r30, 0x90	; 144
 75c:	f0 e0       	ldi	r31, 0x00	; 0
 75e:	80 81       	ld	r24, Z
 760:	81 60       	ori	r24, 0x01	; 1
 762:	80 83       	st	Z, r24
	sbi(TCCR4D, WGM40);		// put timer 4 in phase- and frequency-correct PWM mode	
	sbi(TCCR4A, PWM4A);		// enable PWM mode for comparator OCR4A
	sbi(TCCR4C, PWM4D);		// enable PWM mode for comparator OCR4D
#else /* beginning of timer4 block for ATMEGA1280 and ATMEGA2560 */
#if defined(TCCR4B) && defined(CS41) && defined(WGM40)
	sbi(TCCR4B, CS41);		// set timer 4 prescale factor to 64
 764:	e1 ea       	ldi	r30, 0xA1	; 161
 766:	f0 e0       	ldi	r31, 0x00	; 0
 768:	80 81       	ld	r24, Z
 76a:	82 60       	ori	r24, 0x02	; 2
 76c:	80 83       	st	Z, r24
	sbi(TCCR4B, CS40);
 76e:	80 81       	ld	r24, Z
 770:	81 60       	ori	r24, 0x01	; 1
 772:	80 83       	st	Z, r24
	sbi(TCCR4A, WGM40);		// put timer 4 in 8-bit phase correct pwm mode
 774:	e0 ea       	ldi	r30, 0xA0	; 160
 776:	f0 e0       	ldi	r31, 0x00	; 0
 778:	80 81       	ld	r24, Z
 77a:	81 60       	ori	r24, 0x01	; 1
 77c:	80 83       	st	Z, r24
#endif
#endif /* end timer4 block for ATMEGA1280/2560 and similar */	

#if defined(TCCR5B) && defined(CS51) && defined(WGM50)
	sbi(TCCR5B, CS51);		// set timer 5 prescale factor to 64
 77e:	e1 e2       	ldi	r30, 0x21	; 33
 780:	f1 e0       	ldi	r31, 0x01	; 1
 782:	80 81       	ld	r24, Z
 784:	82 60       	ori	r24, 0x02	; 2
 786:	80 83       	st	Z, r24
	sbi(TCCR5B, CS50);
 788:	80 81       	ld	r24, Z
 78a:	81 60       	ori	r24, 0x01	; 1
 78c:	80 83       	st	Z, r24
	sbi(TCCR5A, WGM50);		// put timer 5 in 8-bit phase correct pwm mode
 78e:	e0 e2       	ldi	r30, 0x20	; 32
 790:	f1 e0       	ldi	r31, 0x01	; 1
 792:	80 81       	ld	r24, Z
 794:	81 60       	ori	r24, 0x01	; 1
 796:	80 83       	st	Z, r24
#if defined(ADCSRA)
	// set a2d prescale factor to 128
	// 16 MHz / 128 = 125 KHz, inside the desired 50-200 KHz range.
	// XXX: this will not work properly for other clock speeds, and
	// this code should use F_CPU to determine the prescale factor.
	sbi(ADCSRA, ADPS2);
 798:	ea e7       	ldi	r30, 0x7A	; 122
 79a:	f0 e0       	ldi	r31, 0x00	; 0
 79c:	80 81       	ld	r24, Z
 79e:	84 60       	ori	r24, 0x04	; 4
 7a0:	80 83       	st	Z, r24
	sbi(ADCSRA, ADPS1);
 7a2:	80 81       	ld	r24, Z
 7a4:	82 60       	ori	r24, 0x02	; 2
 7a6:	80 83       	st	Z, r24
	sbi(ADCSRA, ADPS0);
 7a8:	80 81       	ld	r24, Z
 7aa:	81 60       	ori	r24, 0x01	; 1
 7ac:	80 83       	st	Z, r24

	// enable a2d conversions
	sbi(ADCSRA, ADEN);
 7ae:	80 81       	ld	r24, Z
 7b0:	80 68       	ori	r24, 0x80	; 128
 7b2:	80 83       	st	Z, r24
	// here so they can be used as normal digital i/o; they will be
	// reconnected in Serial.begin()
#if defined(UCSRB)
	UCSRB = 0;
#elif defined(UCSR0B)
	UCSR0B = 0;
 7b4:	10 92 c1 00 	sts	0x00C1, r1
#endif
}
 7b8:	08 95       	ret

000007ba <pinMode>:
#define ARDUINO_MAIN
#include "wiring_private.h"
#include "pins_arduino.h"

void pinMode(uint8_t pin, uint8_t mode)
{
 7ba:	cf 93       	push	r28
 7bc:	df 93       	push	r29
	uint8_t bit = digitalPinToBitMask(pin);
 7be:	48 2f       	mov	r20, r24
 7c0:	50 e0       	ldi	r21, 0x00	; 0
 7c2:	ca 01       	movw	r24, r20
 7c4:	88 58       	subi	r24, 0x88	; 136
 7c6:	9e 4f       	sbci	r25, 0xFE	; 254
 7c8:	fc 01       	movw	r30, r24
 7ca:	34 91       	lpm	r19, Z+
	uint8_t port = digitalPinToPort(pin);
 7cc:	4e 5c       	subi	r20, 0xCE	; 206
 7ce:	5e 4f       	sbci	r21, 0xFE	; 254
 7d0:	fa 01       	movw	r30, r20
 7d2:	84 91       	lpm	r24, Z+
	volatile uint8_t *reg, *out;

	if (port == NOT_A_PIN) return;
 7d4:	88 23       	and	r24, r24
 7d6:	69 f1       	breq	.+90     	; 0x832 <pinMode+0x78>

	// JWS: can I let the optimizer do this?
	reg = portModeRegister(port);
 7d8:	90 e0       	ldi	r25, 0x00	; 0
 7da:	88 0f       	add	r24, r24
 7dc:	99 1f       	adc	r25, r25
 7de:	fc 01       	movw	r30, r24
 7e0:	ec 51       	subi	r30, 0x1C	; 28
 7e2:	ff 4f       	sbci	r31, 0xFF	; 255
 7e4:	a5 91       	lpm	r26, Z+
 7e6:	b4 91       	lpm	r27, Z+
	out = portOutputRegister(port);
 7e8:	fc 01       	movw	r30, r24
 7ea:	e2 50       	subi	r30, 0x02	; 2
 7ec:	ff 4f       	sbci	r31, 0xFF	; 255
 7ee:	c5 91       	lpm	r28, Z+
 7f0:	d4 91       	lpm	r29, Z+

	if (mode == INPUT) { 
 7f2:	66 23       	and	r22, r22
 7f4:	51 f4       	brne	.+20     	; 0x80a <pinMode+0x50>
		uint8_t oldSREG = SREG;
 7f6:	2f b7       	in	r18, 0x3f	; 63
                cli();
 7f8:	f8 94       	cli
		*reg &= ~bit;
 7fa:	8c 91       	ld	r24, X
 7fc:	93 2f       	mov	r25, r19
 7fe:	90 95       	com	r25
 800:	89 23       	and	r24, r25
 802:	8c 93       	st	X, r24
		*out &= ~bit;
 804:	88 81       	ld	r24, Y
 806:	89 23       	and	r24, r25
 808:	0b c0       	rjmp	.+22     	; 0x820 <pinMode+0x66>
		SREG = oldSREG;
	} else if (mode == INPUT_PULLUP) {
 80a:	62 30       	cpi	r22, 0x02	; 2
 80c:	61 f4       	brne	.+24     	; 0x826 <pinMode+0x6c>
		uint8_t oldSREG = SREG;
 80e:	2f b7       	in	r18, 0x3f	; 63
                cli();
 810:	f8 94       	cli
		*reg &= ~bit;
 812:	8c 91       	ld	r24, X
 814:	93 2f       	mov	r25, r19
 816:	90 95       	com	r25
 818:	89 23       	and	r24, r25
 81a:	8c 93       	st	X, r24
		*out |= bit;
 81c:	88 81       	ld	r24, Y
 81e:	83 2b       	or	r24, r19
 820:	88 83       	st	Y, r24
		SREG = oldSREG;
 822:	2f bf       	out	0x3f, r18	; 63
 824:	06 c0       	rjmp	.+12     	; 0x832 <pinMode+0x78>
	} else {
		uint8_t oldSREG = SREG;
 826:	9f b7       	in	r25, 0x3f	; 63
                cli();
 828:	f8 94       	cli
		*reg |= bit;
 82a:	8c 91       	ld	r24, X
 82c:	83 2b       	or	r24, r19
 82e:	8c 93       	st	X, r24
		SREG = oldSREG;
 830:	9f bf       	out	0x3f, r25	; 63
	}
}
 832:	df 91       	pop	r29
 834:	cf 91       	pop	r28
 836:	08 95       	ret

00000838 <turnOffPWM>:
//
//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
//static inline void turnOffPWM(uint8_t timer)
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
 838:	89 30       	cpi	r24, 0x09	; 9
 83a:	09 f4       	brne	.+2      	; 0x83e <turnOffPWM+0x6>
 83c:	49 c0       	rjmp	.+146    	; 0x8d0 <turnOffPWM+0x98>
 83e:	8a 30       	cpi	r24, 0x0A	; 10
 840:	a0 f4       	brcc	.+40     	; 0x86a <turnOffPWM+0x32>
 842:	84 30       	cpi	r24, 0x04	; 4
 844:	51 f1       	breq	.+84     	; 0x89a <turnOffPWM+0x62>
 846:	85 30       	cpi	r24, 0x05	; 5
 848:	40 f4       	brcc	.+16     	; 0x85a <turnOffPWM+0x22>
 84a:	82 30       	cpi	r24, 0x02	; 2
 84c:	79 f1       	breq	.+94     	; 0x8ac <turnOffPWM+0x74>
 84e:	83 30       	cpi	r24, 0x03	; 3
 850:	00 f5       	brcc	.+64     	; 0x892 <turnOffPWM+0x5a>
 852:	81 30       	cpi	r24, 0x01	; 1
 854:	09 f0       	breq	.+2      	; 0x858 <turnOffPWM+0x20>
 856:	63 c0       	rjmp	.+198    	; 0x91e <turnOffPWM+0xe6>
 858:	26 c0       	rjmp	.+76     	; 0x8a6 <turnOffPWM+0x6e>
 85a:	87 30       	cpi	r24, 0x07	; 7
 85c:	79 f1       	breq	.+94     	; 0x8bc <turnOffPWM+0x84>
 85e:	88 30       	cpi	r24, 0x08	; 8
 860:	98 f5       	brcc	.+102    	; 0x8c8 <turnOffPWM+0x90>
 862:	86 30       	cpi	r24, 0x06	; 6
 864:	09 f0       	breq	.+2      	; 0x868 <turnOffPWM+0x30>
 866:	5b c0       	rjmp	.+182    	; 0x91e <turnOffPWM+0xe6>
 868:	25 c0       	rjmp	.+74     	; 0x8b4 <turnOffPWM+0x7c>
 86a:	8d 30       	cpi	r24, 0x0D	; 13
 86c:	09 f4       	brne	.+2      	; 0x870 <turnOffPWM+0x38>
 86e:	42 c0       	rjmp	.+132    	; 0x8f4 <turnOffPWM+0xbc>
 870:	8e 30       	cpi	r24, 0x0E	; 14
 872:	28 f4       	brcc	.+10     	; 0x87e <turnOffPWM+0x46>
 874:	8b 30       	cpi	r24, 0x0B	; 11
 876:	b1 f1       	breq	.+108    	; 0x8e4 <turnOffPWM+0xac>
 878:	8c 30       	cpi	r24, 0x0C	; 12
 87a:	c0 f5       	brcc	.+112    	; 0x8ec <turnOffPWM+0xb4>
 87c:	2d c0       	rjmp	.+90     	; 0x8d8 <turnOffPWM+0xa0>
 87e:	80 31       	cpi	r24, 0x10	; 16
 880:	09 f4       	brne	.+2      	; 0x884 <turnOffPWM+0x4c>
 882:	42 c0       	rjmp	.+132    	; 0x908 <turnOffPWM+0xd0>
 884:	81 31       	cpi	r24, 0x11	; 17
 886:	09 f4       	brne	.+2      	; 0x88a <turnOffPWM+0x52>
 888:	45 c0       	rjmp	.+138    	; 0x914 <turnOffPWM+0xdc>
 88a:	8f 30       	cpi	r24, 0x0F	; 15
 88c:	09 f0       	breq	.+2      	; 0x890 <turnOffPWM+0x58>
 88e:	47 c0       	rjmp	.+142    	; 0x91e <turnOffPWM+0xe6>
 890:	37 c0       	rjmp	.+110    	; 0x900 <turnOffPWM+0xc8>
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
 892:	80 91 80 00 	lds	r24, 0x0080
 896:	8f 77       	andi	r24, 0x7F	; 127
 898:	03 c0       	rjmp	.+6      	; 0x8a0 <turnOffPWM+0x68>
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
 89a:	80 91 80 00 	lds	r24, 0x0080
 89e:	8f 7d       	andi	r24, 0xDF	; 223
 8a0:	80 93 80 00 	sts	0x0080, r24
 8a4:	08 95       	ret
		#if defined(TCCR2) && defined(COM21)
		case  TIMER2:   cbi(TCCR2, COM21);      break;
		#endif
		
		#if defined(TCCR0A) && defined(COM0A1)
		case  TIMER0A:  cbi(TCCR0A, COM0A1);    break;
 8a6:	84 b5       	in	r24, 0x24	; 36
 8a8:	8f 77       	andi	r24, 0x7F	; 127
 8aa:	02 c0       	rjmp	.+4      	; 0x8b0 <turnOffPWM+0x78>
		#endif
		
		#if defined(TIMER0B) && defined(COM0B1)
		case  TIMER0B:  cbi(TCCR0A, COM0B1);    break;
 8ac:	84 b5       	in	r24, 0x24	; 36
 8ae:	8f 7d       	andi	r24, 0xDF	; 223
 8b0:	84 bd       	out	0x24, r24	; 36
 8b2:	08 95       	ret
		#endif
		#if defined(TCCR2A) && defined(COM2A1)
		case  TIMER2A:  cbi(TCCR2A, COM2A1);    break;
 8b4:	80 91 b0 00 	lds	r24, 0x00B0
 8b8:	8f 77       	andi	r24, 0x7F	; 127
 8ba:	03 c0       	rjmp	.+6      	; 0x8c2 <turnOffPWM+0x8a>
		#endif
		#if defined(TCCR2A) && defined(COM2B1)
		case  TIMER2B:  cbi(TCCR2A, COM2B1);    break;
 8bc:	80 91 b0 00 	lds	r24, 0x00B0
 8c0:	8f 7d       	andi	r24, 0xDF	; 223
 8c2:	80 93 b0 00 	sts	0x00B0, r24
 8c6:	08 95       	ret
		#endif
		
		#if defined(TCCR3A) && defined(COM3A1)
		case  TIMER3A:  cbi(TCCR3A, COM3A1);    break;
 8c8:	80 91 90 00 	lds	r24, 0x0090
 8cc:	8f 77       	andi	r24, 0x7F	; 127
 8ce:	07 c0       	rjmp	.+14     	; 0x8de <turnOffPWM+0xa6>
		#endif
		#if defined(TCCR3A) && defined(COM3B1)
		case  TIMER3B:  cbi(TCCR3A, COM3B1);    break;
 8d0:	80 91 90 00 	lds	r24, 0x0090
 8d4:	8f 7d       	andi	r24, 0xDF	; 223
 8d6:	03 c0       	rjmp	.+6      	; 0x8de <turnOffPWM+0xa6>
		#endif
		#if defined(TCCR3A) && defined(COM3C1)
		case  TIMER3C:  cbi(TCCR3A, COM3C1);    break;
 8d8:	80 91 90 00 	lds	r24, 0x0090
 8dc:	87 7f       	andi	r24, 0xF7	; 247
 8de:	80 93 90 00 	sts	0x0090, r24
 8e2:	08 95       	ret
		#endif

		#if defined(TCCR4A) && defined(COM4A1)
		case  TIMER4A:  cbi(TCCR4A, COM4A1);    break;
 8e4:	80 91 a0 00 	lds	r24, 0x00A0
 8e8:	8f 77       	andi	r24, 0x7F	; 127
 8ea:	07 c0       	rjmp	.+14     	; 0x8fa <turnOffPWM+0xc2>
		#endif					
		#if defined(TCCR4A) && defined(COM4B1)
		case  TIMER4B:  cbi(TCCR4A, COM4B1);    break;
 8ec:	80 91 a0 00 	lds	r24, 0x00A0
 8f0:	8f 7d       	andi	r24, 0xDF	; 223
 8f2:	03 c0       	rjmp	.+6      	; 0x8fa <turnOffPWM+0xc2>
		#endif
		#if defined(TCCR4A) && defined(COM4C1)
		case  TIMER4C:  cbi(TCCR4A, COM4C1);    break;
 8f4:	80 91 a0 00 	lds	r24, 0x00A0
 8f8:	87 7f       	andi	r24, 0xF7	; 247
 8fa:	80 93 a0 00 	sts	0x00A0, r24
 8fe:	08 95       	ret
		#if defined(TCCR4C) && defined(COM4D1)
		case TIMER4D:	cbi(TCCR4C, COM4D1);	break;
		#endif			
			
		#if defined(TCCR5A)
		case  TIMER5A:  cbi(TCCR5A, COM5A1);    break;
 900:	80 91 20 01 	lds	r24, 0x0120
 904:	8f 77       	andi	r24, 0x7F	; 127
 906:	03 c0       	rjmp	.+6      	; 0x90e <turnOffPWM+0xd6>
		case  TIMER5B:  cbi(TCCR5A, COM5B1);    break;
 908:	80 91 20 01 	lds	r24, 0x0120
 90c:	8f 7d       	andi	r24, 0xDF	; 223
 90e:	80 93 20 01 	sts	0x0120, r24
 912:	08 95       	ret
		case  TIMER5C:  cbi(TCCR5A, COM5C1);    break;
 914:	80 91 20 01 	lds	r24, 0x0120
 918:	87 7f       	andi	r24, 0xF7	; 247
 91a:	80 93 20 01 	sts	0x0120, r24
 91e:	08 95       	ret

00000920 <digitalWrite>:
		#endif
	}
}

void digitalWrite(uint8_t pin, uint8_t val)
{
 920:	ff 92       	push	r15
 922:	0f 93       	push	r16
 924:	1f 93       	push	r17
 926:	f6 2e       	mov	r15, r22
	uint8_t timer = digitalPinToTimer(pin);
 928:	48 2f       	mov	r20, r24
 92a:	50 e0       	ldi	r21, 0x00	; 0
 92c:	ca 01       	movw	r24, r20
 92e:	82 54       	subi	r24, 0x42	; 66
 930:	9e 4f       	sbci	r25, 0xFE	; 254
 932:	fc 01       	movw	r30, r24
 934:	24 91       	lpm	r18, Z+
	uint8_t bit = digitalPinToBitMask(pin);
 936:	ca 01       	movw	r24, r20
 938:	88 58       	subi	r24, 0x88	; 136
 93a:	9e 4f       	sbci	r25, 0xFE	; 254
 93c:	fc 01       	movw	r30, r24
 93e:	14 91       	lpm	r17, Z+
	uint8_t port = digitalPinToPort(pin);
 940:	4e 5c       	subi	r20, 0xCE	; 206
 942:	5e 4f       	sbci	r21, 0xFE	; 254
 944:	fa 01       	movw	r30, r20
 946:	04 91       	lpm	r16, Z+
	volatile uint8_t *out;

	if (port == NOT_A_PIN) return;
 948:	00 23       	and	r16, r16
 94a:	c9 f0       	breq	.+50     	; 0x97e <digitalWrite+0x5e>

	// If the pin that support PWM output, we need to turn it off
	// before doing a digital write.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
 94c:	22 23       	and	r18, r18
 94e:	19 f0       	breq	.+6      	; 0x956 <digitalWrite+0x36>
 950:	82 2f       	mov	r24, r18
 952:	0e 94 1c 04 	call	0x838	; 0x838 <turnOffPWM>

	out = portOutputRegister(port);
 956:	e0 2f       	mov	r30, r16
 958:	f0 e0       	ldi	r31, 0x00	; 0
 95a:	ee 0f       	add	r30, r30
 95c:	ff 1f       	adc	r31, r31
 95e:	e2 50       	subi	r30, 0x02	; 2
 960:	ff 4f       	sbci	r31, 0xFF	; 255
 962:	a5 91       	lpm	r26, Z+
 964:	b4 91       	lpm	r27, Z+

	uint8_t oldSREG = SREG;
 966:	9f b7       	in	r25, 0x3f	; 63
	cli();
 968:	f8 94       	cli

	if (val == LOW) {
 96a:	ff 20       	and	r15, r15
 96c:	21 f4       	brne	.+8      	; 0x976 <digitalWrite+0x56>
		*out &= ~bit;
 96e:	8c 91       	ld	r24, X
 970:	10 95       	com	r17
 972:	81 23       	and	r24, r17
 974:	02 c0       	rjmp	.+4      	; 0x97a <digitalWrite+0x5a>
	} else {
		*out |= bit;
 976:	8c 91       	ld	r24, X
 978:	81 2b       	or	r24, r17
 97a:	8c 93       	st	X, r24
	}

	SREG = oldSREG;
 97c:	9f bf       	out	0x3f, r25	; 63
}
 97e:	1f 91       	pop	r17
 980:	0f 91       	pop	r16
 982:	ff 90       	pop	r15
 984:	08 95       	ret

00000986 <__tablejump2__>:
 986:	ee 0f       	add	r30, r30
 988:	ff 1f       	adc	r31, r31

0000098a <__tablejump__>:
 98a:	05 90       	lpm	r0, Z+
 98c:	f4 91       	lpm	r31, Z+
 98e:	e0 2d       	mov	r30, r0
 990:	19 94       	eijmp

00000992 <_exit>:
 992:	f8 94       	cli

00000994 <__stop_program>:
 994:	ff cf       	rjmp	.-2      	; 0x994 <__stop_program>
